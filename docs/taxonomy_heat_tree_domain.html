<!DOCTYPE html>
<meta charset="utf-8">
<style>
  body { font-family: sans-serif; }
  .node circle { stroke: #555; stroke-width: 1.5px; }
  .node text { font: 12px sans-serif; }
  .link { stroke: #999; stroke-width: 1; stroke-opacity: 0.6; }
</style>
<body>
<svg width="1000" height="1000"></svg>
<script src="https://d3js.org/d3.v7.min.js"></script>
<script>

d3.json("heat_tree_data.json").then(function(data) {

  const width = 1000, height = 1000;
  const radius = width / 2 - 100;

  const svg = d3.select("svg")
      .attr("viewBox", [-width/2, -height/2, width, height]);

  // Build a root hierarchy with only domains
  const root = { name: "Root", children: data.heat_tree.map(d => ({...d, children: []})) };
  const hierarchy = d3.hierarchy(root);

  const cluster = d3.cluster().size([2 * Math.PI, radius]);
  cluster(hierarchy);

  // Scales
  const colorScale = d3.scaleLinear().domain([0, 1]).range(["#ccc", "#006400"]);
  const maxScore = d3.max(hierarchy.descendants(), d => d.data.score || 0) || 1;
  const sizeScale = d3.scaleSqrt().domain([0, maxScore]).range([6, 20]);

  // --- Nodes (domains only) ---
  const nodes = hierarchy.children;  // skip the artificial root

  const node = svg.append("g")
    .selectAll("g")
    .data(nodes)
    .join("g")
      .attr("transform", d => {
        return `translate(${d.y * Math.cos(d.x - Math.PI/2)}, ${d.y * Math.sin(d.x - Math.PI/2)})`;
      });

  node.append("circle")
      .attr("r", d => sizeScale(d.data.score || 0))
      .attr("fill", d => colorScale(d.data.heat || 0));

  node.append("text")
      .attr("dy", "0.31em")
      .attr("transform", d => {
        const angle = (d.x * 180 / Math.PI) - 90;
        const rotate = angle + (d.x >= Math.PI ? 180 : 0);
        const offset = sizeScale(d.data.score || 0) + 6;
        return `rotate(${rotate}) translate(${offset},0)`;
      })
      .attr("text-anchor", d => d.x >= Math.PI ? "end" : "start")
      .text(d => d.data.id || "");

  // --- RelatedTo Links (gray, weight=1) ---
  svg.append("g")
    .selectAll("line")
    .data(data.links)
    .join("line")
      .attr("stroke", "#999")
      .attr("stroke-width", 1)
      .attr("x1", d => {
        let node = nodes.find(n => n.data.id === d.source);
        return node ? node.y * Math.cos(node.x - Math.PI/2) : 0;
      })
      .attr("y1", d => {
        let node = nodes.find(n => n.data.id === d.source);
        return node ? node.y * Math.sin(node.x - Math.PI/2) : 0;
      })
      .attr("x2", d => {
        let node = nodes.find(n => n.data.id === d.target);
        return node ? node.y * Math.cos(node.x - Math.PI/2) : 0;
      })
      .attr("y2", d => {
        let node = nodes.find(n => n.data.id === d.target);
        return node ? node.y * Math.sin(node.x - Math.PI/2) : 0;
      });

});

</script>
</body>
